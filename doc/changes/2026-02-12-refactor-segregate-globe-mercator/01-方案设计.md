# 01 方案设计

## 1. 问题定义

现状存在一个关键语义问题：投影配置是二选一，但运行时链路并非二选一。

- 当设置 `projection: 'globe'` 时，当前实现会在 Globe 与 Mercator 之间按缩放进行内部过渡；
- `GlobeProjection`、`GlobeTransform`、`GlobeCameraHelper` 内部都存在双实现分支；
- 业务和测试侧常将 `'globe'` 理解为稳定模式，但实际是混合模式。

这导致可预测性和可维护性下降，且对后续 Globe 专项优化形成阻碍。

## 2. 约束条件

- 对外样式字段保持兼容：`projection.type` 仍支持 `'globe'` 与 `'mercator'`；
- 非显式切换投影时，不应触发任何投影链路切换；
- 需要支持快速回滚，避免一次性切断旧逻辑风险；
- 不降低当前主流场景渲染与交互性能。

## 3. 方案概述

引入严格投影模式（Strict Projection Mode）：

- `projection: 'globe'` -> 始终走纯 Globe 链路（VerticalPerspective Projection/Transform/Camera）；
- `projection: 'mercator'` -> 始终走纯 Mercator 链路；
- 删除或冻结 Globe 内部过渡状态（transitionState/globeness）对主逻辑的影响；
- 投影切换只在调用 `setProjection` 时发生。

## 4. 详细设计

### 4.1 架构变更

从混合架构改为严格分离架构：

- **当前**：`Globe*` 组件内部持有 `Mercator*` 与 `VerticalPerspective*`，并按状态切换。
- **目标**：`projection_factory` 直接返回单一链路对象，运行时不再隐式跨链路。

灰度开关保留为**内部发布配置**（不新增对外 API）：

```ts
type ProjectionSegregationMode = 'legacy-hybrid' | 'strict';
```

默认策略建议：

- 短期默认 `legacy-hybrid`（降低升级风险）；
- 灰度稳定后切到 `strict` 默认。

### 4.2 模块变更

- `src/geo/projection/projection_factory.ts`
  - `globe` 分支直接构建纯 Globe 组件，不再注入缩放插值定义。
- `src/geo/projection/globe_projection.ts`
  - 去除内部 `MercatorProjection` 依赖或将其降为兼容分支；
  - `useGlobeRendering` 固定为 `true`（在 strict 模式下）。
- `src/geo/projection/globe_transform.ts`
  - 去除 `_mercatorTransform` 参与主流程；
  - 收敛 `setTransitionState/currentTransform` 的双分支行为。
- `src/geo/projection/globe_camera_helper.ts`
  - 去除基于过渡状态的控制路径切换。
- `src/ui/map.ts`
  - 渲染循环中 `transitionState`/`globeRenderingChanged` 相关逻辑按 strict 模式简化；
  - `projectiontransition` 事件语义改为仅显式切换触发。
- `src/ui/events.ts`
  - 更新 `projectiontransition` 注释说明，移除内部过渡文案。

### 4.3 接口变更（最终版，与当前代码对齐）

本次不新增任何公开 API，沿用现有接口并收敛其行为语义。

Map 对外接口（保持不变）：

```ts
import type {ProjectionSpecification} from '@maplibre/maplibre-gl-style-spec';

map.getProjection(): ProjectionSpecification;
map.setProjection(projection: ProjectionSpecification): Map;
```

Style 层接口（保持不变）：

```ts
style.getProjection(): ProjectionSpecification;
style.setProjection(projection: ProjectionSpecification): void;
```

事件接口（保持不变）：

```ts
type MapProjectionEvent = {
  type: 'projectiontransition';
  newProjection: ProjectionSpecification['type'];
};
```

最终语义约束（本次重构后）：

- 当 `projection.type` 设置为 `'globe'` 时，运行时链路恒为 Globe；
- 当 `projection.type` 设置为 `'mercator'` 时，运行时链路恒为 Mercator；
- `projectiontransition` 仅在显式调用 `setProjection(...)` 或样式切换导致投影变化时触发；
- 灰度与回滚通过内部发布配置控制，不通过新的业务 API 暴露。

### 4.4 数据结构变更

建议新增运行时状态结构：

```ts
interface ProjectionRuntimeState {
  configuredProjection: 'mercator' | 'globe';
  activeProjection: 'mercator' | 'globe';
  segregationMode: 'legacy-hybrid' | 'strict';
}
```

在 `strict` 模式下约束：

- `activeProjection === configuredProjection` 恒成立。

## 5. 备选方案对比

- 方案 A：保留混合架构，仅强化注释
  - 优点：改动最小
  - 缺点：问题根因不解决
- 方案 B：严格分离 + 灰度开关（本方案）
  - 优点：长期收益高、风险可控
  - 缺点：短期需要维护双路径
- 方案 C：一次性删除旧逻辑
  - 优点：代码最干净
  - 缺点：发布风险高，回滚成本大

结论：采用方案 B。

## 6. 向后兼容性评估

- API 兼容：`setProjection` 与样式字段不变；
- 行为变化：仅在开启 `strict` 时生效；
- 数据兼容：无持久化数据迁移需求；
- 渲染兼容：Mercator 现有场景应与现状保持一致。

## 7. 风险与回滚点

主要风险：

- 临界缩放视觉效果与历史版本存在差异；
- 旧用例可能隐式依赖混合模式；
- Globe 专项链路在高缩放场景下性能波动。

回滚方案：

- 运行时将 `segregationMode` 降级为 `legacy-hybrid`；
- 保留 legacy 路径一段发布周期，观察数据稳定后再删除；
- 若线上异常持续，执行版本回滚。

## 8. 评审结论

- 当前状态：草稿待评审
- 评审重点：
  - strict 模式下是否真正满足单链路不切换；
  - 事件与文档语义是否一致；
  - 性能与回归指标是否达标。
